#' Run all tests for an exercise
#'
#' Run all tests for an exercise and report the results (including feedback).
#' This function is run by R Backend and should not be used by course creators.
#'
#' @param sct Submission correctness tests as a character string.
#' @param ex_type Type of the exercise
#' @param pec pre-exercise-code
#' @param student_code character string representing the student code
#' @param solution_code character string representing the solution code
#' @param student_env environment containing the objects defined by the student.
#' @param solution_env environment containing the objects defined by solution code
#' @param output_list the output structure that is generated by RBackend
#' @param seed random seed that is used for SCTs that run expressions.
#'
#' @return A list with components \code{passed} that indicates whether all
#' tests were sucessful, and \code{feedback} that contains a feedback message.
#'
#' @export
test_exercise <- function(sct, 
                          ex_type, 
                          pec,
                          student_code,
                          solution_code,
                          student_env,
                          solution_env,
                          output_list,
                          seed = 42) {
  # backwards compatibility with older versions of RBackend
  if (missing(student_env)) {
    student_env <- globalenv()
  }
  
  # First check if parsing worked out
  if (any(sapply(output_list, `[[`, "type") == "parse-error")) {
    report <- tryCatch(do_parse(student_code),
                       error = function(e) {
                         list(message = parse_fallback_msg)
                       })
    return(c(list(correct = FALSE), report))
  } else {
    # Store everything that's needed locally (initialize does a full reset)
    tw$clear()
    tw$set(success_msg = sample(c("Good Job!", "Well done!", "Great work!"), 1))
    state <- RootState$new(pec = pec,
                           student_code = student_code,
                           student_pd = build_pd(student_code),
                           student_env = student_env,
                           solution_code = solution_code,
                           solution_pd = build_pd(solution_code),
                           solution_env = solution_env,
                           output_list = output_list,
                           test_env = new.env(parent = environment()))
    tw$set(state = state,
           stack = TRUE,
           seed = seed)
    on.exit(tw$clear())
    
    # Execute sct with the DataCamp reporter such that it collects test results
    res <- run_until_fail(parse(text = sct))
    return(post_process(res, ex_type))
  }
}

#' Run SCT until it fails
#'
#' @param code the SCT script to run as an expression
#'
#' @export
run_until_fail <- function(code) {
  end_expr <- expression(return(list(correct = TRUE, message = tw$get("success_msg"))))
  tryCatch(eval(c(code, end_expr), envir = tw$get("state")$get("test_env")),
           sct_failure = function(e) {
             return(list(correct = FALSE,
                         message = e$message,
                         feedback = attr(e, "feedback")))
           })
}

post_process <- function(res, ex_type) {
  # convert to HTML
  res$message <- to_html(res$message)
  
  # Only add line info if:
  # - message is incorrect, and
  # - exercise is not markdown / rcpp (post-processing of code chunks gives strange things)
  if (!res$correct && !(ex_type %in% c("MarkdownExercise", "RCppExercise"))) {
    line_info <- get_line_info(res$feedback)
    if (!is.null(line_info)) {
      res <- c(res, line_info)
    }
  }
  res$feedback <- NULL
  return(res)
}